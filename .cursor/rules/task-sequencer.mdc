---
description: description: "Task Sequencer (v1.2): Executes defined 'prompt sequences' of .md task files. Processes all tasks within a sequence, then optionally triggers a 'Regular Debug Mode' cycle for the code generated by that sequence. Manages progress via prompt-log.md and sequence definitions from a dedicated sequences file (e.g., prompt_sequences.md)."tags: ["automation", "batch-processing", "task-execution", "prompt-sequencing", "sequence-debug"]
globs: 
alwaysApply: false
---

---
description: "Task Sequencer (v1.2): Executes defined 'prompt sequences' of .md task files. Processes all tasks within a sequence, then optionally triggers a 'Regular Debug Mode' cycle for the code generated by that sequence. Manages progress via prompt-log.md and sequence definitions from a dedicated sequences file (e.g., prompt_sequences.md)."
# Can be Agent Requested or Manual.
tags: ["automation", "batch-processing", "task-execution", "prompt-sequencing", "sequence-debug"]
version: "1.2.0"
---

<TaskSequencer_V1_2>

    <ScopeAndObjective>
        You are activating the "Task Sequencer" (Version 1.2).
        Your objective is to process defined **prompt sequences**. Each sequence consists of multiple .md task files that are logically grouped and potentially interdependent.
        You will:
        1. Read sequence definitions from a dedicated file (e.g., `prompt_sequences.md`).
        2. Process sequences one by one. For each sequence:
            a. Execute all its constituent .md task files in their defined order, adhering to Maestro principles.
            b. After an entire sequence is executed, initiate ONE "Regular Debug Mode" cycle for the code generated/modified by that ENTIRE sequence.
        3. Manage overall progress and individual task status via `prompt-log.md`.
        This rule operates under the overarching principles of the "Maestro Workflow Engine."
    </ScopeAndObjective>

    <Configuration>
        <TaskDirectory>
            Base directory for individual .md task files: `./ai_tasks/` (User may specify a different base path).
        </TaskDirectory>
        <SequenceDefinitionFile>
            File defining prompt sequences: `prompt_sequences.md` (expected in project root, or user-specified).
            Example format for `prompt_sequences.md`:
            ```markdown
            # Prompt Sequences

            ## Sequence: [SequenceName1]
            - path/to/task01.md
            - path/to/task02.md

            ## Sequence: [SequenceName2]
            - another/path/taskA.md
            - another/path/taskB.md
            ```
            (Paths in sequence definitions can be relative to project root or the TaskDirectory).
        </SequenceDefinitionFile>
        <IndividualTaskLogFile>
            Log for individual .md task completions: `prompt-log.md` (in project root).
        </IndividualTaskLogFile>
        <SequenceLogFile>
            Log for sequence completions: `sequence_log.md` (in project root).
        </SequenceLogFile>
    </Configuration>

    <Phase1_SequenceAndTaskListPreparation>
        <Instruction>
            1.  **Locate Sequence Definition File**:
                * Default path: `prompt_sequences.md` in the project root. Allow user to specify an alternative path.
                * Use `read_file` to load its content. If not found, inform user and gracefully terminate (as sequences are now central).
            2.  **Parse Sequence Definitions**:
                * Parse the content of the sequence definition file to identify all defined sequences and the ordered list of .md task files for each.
                * Store this parsed structure (e.g., a list of sequences, where each sequence is a list of task file paths).
            3.  **Read Completion Logs**:
                * Use `read_file` to get content of `prompt-log.md` (for individual tasks) and `sequence_log.md` (for sequences). If they don't exist, treat as empty.
            4.  **Filter Completed Sequences**: From the parsed sequences, identify which sequences are already marked as fully "erledigt" (completed) in `sequence_log.md`. These can be skipped unless the user requests a re-run.
            5.  **Determine Next Sequence to Process**: Select the first pending sequence based on the order in `prompt_sequences.md`.
            6.  **Report Plan**: Inform the user: "Task Sequencer initialized. Found [N] sequences in `prompt_sequences.md`. [M] sequences pending. Next to process: Sequence '[SelectedSequenceName]' with [K] tasks."
        </Instruction>
    </Phase1_SequenceAndTaskListPreparation>

    <Phase2_ProcessCurrentSequence>
        <Instruction>
            If no pending sequence is selected (all are completed or file was empty), proceed to `<Phase6_CompletionAllSequences>`.
            Let the `current_sequence` be the selected one.
            Let `tasks_in_current_sequence` be the ordered list of .md files for `current_sequence`.
            Let `all_tasks_in_sequence_successful = true`.

            For each `current_task_md_path` in `tasks_in_current_sequence`:
                1.  **Check Individual Task Log**: See if `current_task_md_path` is already marked "erledigt" in `prompt-log.md`. If so, and if not part of a previously failed/incomplete sequence run, it can be skipped. (More robust: typically re-run all tasks in a sequence if sequence wasn't completed). For simplicity now: assume tasks in a sequence are always processed if the sequence itself is pending, unless user specifies otherwise.
                2.  **Security Check (Phase 2a)**:
                    * Load content of `current_task_md_path` using `read_file`.
                    * Perform security analysis (destructive actions, loops, preconditions) as detailed in `<Phase3_SecurityCheckAndConfirmation>` of the previous Task Sequencer version (v1.1.0).
                    * If risks are found, ask user for Yes/No confirmation.
                    * If user says No: Mark `current_task_md_path` as "übersprungen (Sicherheitsbedenken)" in `prompt-log.md`. Set `all_tasks_in_sequence_successful = false`. Break from processing this sequence (or ask user if other tasks in sequence should be attempted). For now, assume sequence processing stops on such a skip. Proceed to `<Phase3_PostSequenceActions>`.
                3.  **Execute Task (Phase 2b)**:
                    * Announce: "Executing task `current_task_md_path` as part of sequence `current_sequence.name`."
                    * Execute instructions from `current_task_md_path` under FULL Maestro Workflow Engine principles.
                    * If execution fails catastrophically (Maestro indicates unrecoverable error for this task):
                        * Log `current_task_md_path` as "fehlgeschlagen (Ausführungsfehler)" in `prompt-log.md` with reason.
                        * Set `all_tasks_in_sequence_successful = false`.
                        * Break from processing this sequence (or ask user). For now, assume sequence processing stops. Proceed to `<Phase3_PostSequenceActions>`.
                    * If execution successful:
                        * Log `current_task_md_path` as "erledigt" in `prompt-log.md`.
            If loop finishes (all tasks in sequence attempted), proceed to `<Phase3_PostSequenceActions>`.
        </Instruction>
    </Phase2_ProcessCurrentSequence>

    <Phase3_PostSequenceActions> // Renamed and refocused
        <Instruction>
            Now, actions for the `current_sequence` after attempting all its tasks:

            If `all_tasks_in_sequence_successful` is `true`:
                1.  **Initiate Regular Debugging for the Sequence**:
                    * Inform the user: "All tasks in sequence '`current_sequence.name`' completed. Initiating 'Regular Debug Mode' for the code generated/modified by this entire sequence."
                    * You will now guide the LLM to apply the logic of the "Regular Debug Mode" (as if `debug-regular.mdc` v1.1.0 with its scoped interdependency mapping were called).
                    * The scope for this debug cycle is ALL code generated or modified by ALL tasks within the `current_sequence`.
                    * **Important**: Since debugging happens AFTER the ENTIRE sequence, the previous complex conditional logic (ignoring errors due to future unimplemented parts *within* the sequence) is NO LONGER NEEDED for this debug call. All parts of *this* sequence should now be implemented. `debug-regular` should focus on true errors and interdependencies within the work product of this sequence.
                    * The `debug-regular` process will update `debug_log.md` as per its own definition.
                2.  **Log Sequence Success**: After the debug cycle (regardless of its findings, as `debug-regular` handles its own logging and might report issues):
                    * Append to `sequence_log.md`: `YYYY-MM-DD HH:MM:SS - erledigt: Sequence '[current_sequence.name]'`.
            Else (if `all_tasks_in_sequence_successful` is `false` due to a skipped or failed task):
                1.  **Log Sequence Failure/Incompletion**:
                    * Append to `sequence_log.md`: `YYYY-MM-DD HH:MM:SS - fehlgeschlagen: Sequence '[current_sequence.name]' - Reason: One or more tasks failed or were skipped. See prompt-log.md for details.`
                2.  **Skip Debugging**: Do not run `debug-regular` if the sequence did not complete fully.
            Proceed to `<Phase4_LoopOrCompleteAll>`.
        </Instruction>
    </Phase3_PostSequenceActions>

    <Phase4_LoopOrCompleteAll> // Renamed
        <Instruction>
            Go back to `<Phase1_SequenceAndTaskListPreparation>` (Step 5) to select and process the next pending sequence.
            If no more pending sequences, proceed to `<Phase5_CompletionAllSequences>`.
        </Instruction>
    </Phase4_LoopOrCompleteAll>

    <Phase5_CompletionAllSequences> // Renamed
        <Instruction>
            Inform the user: "Task Sequencer has completed processing all defined sequences from `prompt_sequences.md`."
            Provide a summary from `sequence_log.md` if useful (e.g., number of sequences completed, failed).
        </Instruction>
    </Phase5_CompletionAllSequences>

</TaskSequencer_V1_2>